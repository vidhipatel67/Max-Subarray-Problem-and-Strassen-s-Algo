# -*- coding: utf-8 -*-#from numpy import *import numpy as npimport math#STOCK_PRICES  = [100,113,110,85,105,102,86,63,81,101,94,106,101,79,94,90,97]STOCK_PRICE_CHANGES =[13,-3,-25,20,-3,-16,-23,18,20,-7,12,-5,-22,15,-4,7]def find_maximum_subarray_brute(A, low=0, high=-1):    """        Find the maximum subarray by brute force        Return a tuple (i,j) where A[i:j] is the maximum subarray.        """    maxsum = 0    for i in range(len(A)):        newsum = 0        for j in range(i, len(A)):            newsum = newsum + A[j]            if newsum > maxsum:                maxsum = newsum                low = i                high = j    t = (low, high)    return tdef find_maximum_crossing_subarray(A, low, mid,  high):    """    Find the maximum subarray that crosses mid    Return a tuple (i,j) where A[i:j] is the maximum subarray.    """    #Initialize the variables    left_sum = -np.inf    right_sum = -np.inf    sum = 0    max_left = 0    max_right = 0    # Get the maximum subarray index from mid to left side of the array    for i in range(mid, low, -1):        sum = sum + A[i]        if sum > left_sum:            left_sum = sum            max_left = i    sum = 0    # Get the maximum subarray index from mid to right side of the array    for j in range(mid+1, high):        sum = sum + A[j]        if sum > right_sum:            right_sum = sum            max_right = j    t = (max_left, max_right, left_sum+right_sum)    return tdef find_maximum_subarray_recursive(A, low=0, high=-1):    """    Return a tuple (i,j) where A[i:j] is the maximum subarray.    Recursive method from chapter 4    """    # Base case when the array size is 1    if high == low:        return low, high, A[low]    else:    # Get mid of the array and find out the maximum array using divide and conquer recursively        mid = math.floor((low+high)/2)        (left_low, left_high, left_sum) = find_maximum_subarray_recursive(A, low, mid)        (right_low, right_high, right_sum) = find_maximum_subarray_recursive(A, mid+1, high)        (cross_low, cross_high, cross_sum) = find_maximum_crossing_subarray(A, low, mid, high)        if left_sum >= right_sum & left_sum >= cross_sum:            return left_low, left_high, left_sum        elif right_sum >= left_sum & right_sum >= cross_sum:            return right_low, right_high, right_sum        else:            return cross_low, cross_high, cross_sumdef find_maximum_subarray_iterative(A, low, high):    # Initialize variables    left = 0    right = 0    sum = A[low]    temp_sum = 0    temp_left = 0    # Get maximum subarray in linear time by dynamically adjusting the left-index to find the maximum subarray    for i in range(low, high):        temp_sum = temp_sum + A[i]        if A[i] > temp_sum:            temp_sum = A[i]        if temp_sum > sum:            sum = temp_sum            right = i            left = temp_left        if temp_sum == A[i]:            temp_left = i    t = (left, right)    return tdef square_matrix_multiply(A, B):    """    Return the product AB of matrix multiplication.    """    A = np.asarray(A)    B = np.asarray(B)    assert A.shape == B.shape    assert A.shape == A.T.shape    # Matrix multiplication C(i,j) = A(i,j) * B(i,j)    s = A.shape    n = s[0]    C = np.asarray([[0 for j in range(0, n)] for i in range(0, n)])    for i in range(n):        for j in range(n):            C[i, j] = 0            for k in range(n):                C[i, j] = C[i, j] + A[i, k] * B[k, j]    return C# Subtraction of 2 matricesdef sub(A, B):    n = len(A)    C = [[0 for j in range(0, n)] for i in range(0, n)]    for i in range(0, n):        for j in range(0, n):            C[i][j] = A[i][j] - B[i][j]    return C# Addition of 2 matricesdef add(A, B):    n = len(A)    C = [[0 for j in range(0, n)] for i in range(0, n)]    for i in range(0, n):        for j in range(0, n):            C[i][j] = A[i][j] + B[i][j]    return Cdef square_matrix_multiply_strassens(A, B):    """    Return the product AB of matrix multiplication.    Assume len(A) is a power of 2    """    A = np.asarray(A)    B = np.asarray(B)    assert A.shape == B.shape    assert A.shape == A.T.shape    assert (len(A) & (len(A) -1)) == 0, "A is not a power of 2"    n = len(A)    C = np.asarray([[0 for j in range(0, n)] for i in range(0, n)])    if n == 1:        C[0][0] = A[0][0] * B[0][0]    else:        new_size = math.floor(n/2)        # STEP 1 :  Divide the input matrices A and B and output matrix C into n=2 X n=2 submatrices, as in equation 4.9        A11 = [[0 for j in range(0, new_size)] for i in range(0, new_size)]        A12 = [[0 for j in range(0, new_size)] for i in range(0, new_size)]        A21 = [[0 for j in range(0, new_size)] for i in range(0, new_size)]        A22 = [[0 for j in range(0, new_size)] for i in range(0, new_size)]        B11 = [[0 for j in range(0, new_size)] for i in range(0, new_size)]        B12 = [[0 for j in range(0, new_size)] for i in range(0, new_size)]        B21 = [[0 for j in range(0, new_size)] for i in range(0, new_size)]        B22 = [[0 for j in range(0, new_size)] for i in range(0, new_size)]        for i in range(0, new_size):            for j in range(0, new_size):                A11[i][j] = A[i][j]  # top left                A12[i][j] = A[i][j + new_size]  # top right                A21[i][j] = A[i + new_size][j]  # bottom left                A22[i][j] = A[i + new_size][j + new_size]  # bottom right                B11[i][j] = B[i][j]  # top left                B12[i][j] = B[i][j + new_size]  # top right                B21[i][j] = B[i + new_size][j]  # bottom left                B22[i][j] = B[i + new_size][j + new_size]  # bottom right        # Step 2: Create 10 matrices S1;S2;:::;S10, each of which is n=2 X n=2            S1 = sub(B12, B22)            S2 = add(A11, A12)            S3 = add(A21, A22)            S4 = sub(B21, B11)            S5 = add(A11, A22)            S6 = add(B11, B22)            S7 = sub(A12, A22)            S8 = add(B21, B22)            S9 = sub(A11, A21)            S10 = add(B11, B12)        # STEP 3: Compute seven matrix products P1,P2....P7            P1 = square_matrix_multiply_strassens(A11, S1)            P2 = square_matrix_multiply_strassens(S2, B22)            P3 = square_matrix_multiply_strassens(S3, B11)            P4 = square_matrix_multiply_strassens(A22, S4)            P5 = square_matrix_multiply_strassens(S5, S6)            P6 = square_matrix_multiply_strassens(S7, S8)            P7 = square_matrix_multiply_strassens(S9, S10)        # STEP 4: calculate the final product of sub matrices            c11 = add(add(P4,P5), sub(P6, P2))      # P4 + P5 + P6 - P2            c12 = add(P1, P2)                       # P1 + P2            c21 = add(P3, P4)                       # P3 + P4            c22 = sub(add(P1, P5), add(P3, P7))     # P1 + P5 - P3 - P7        # Grouping the results obtained in a single matrix:        C = np.asarray([[0 for j in range(0, n)] for i in range(0, n)])        for i in range(0, new_size):            for j in range(0, new_size):                C[i][j] = c11[i][j]                C[i][j + new_size] = c12[i][j]                C[i + new_size][j] = c21[i][j]                C[i + new_size][j + new_size] = c22[i][j]    return C    passdef test():    print("STOCK PRICE CHAGES ARRAY:")    print(STOCK_PRICE_CHANGES)    print("MAXIMUM SUBARRAY USING BRUTE FORCE FOR THIS ARRAY HAVE THE FOLLOWING INDICES:")    ans1 = find_maximum_subarray_brute(STOCK_PRICE_CHANGES,0,-1)    print(ans1)    low = 0    high = len(STOCK_PRICE_CHANGES)-1    print("MAXIMUM SUBARRAY USING RECURSIVE METHOD FOR THIS ARRAY HAVE THE FOLLOWING INDICES:")    ans2 = find_maximum_subarray_recursive(STOCK_PRICE_CHANGES, low, high)    ans_tuple = (ans2[0], ans2[1])    print(ans_tuple)    print("MAXIMUM SUBARRAY USING ITERATIVE METHOD FOR THIS ARRAY HAVE THE FOLLOWING INDICES:")    ans3 = find_maximum_subarray_iterative(STOCK_PRICE_CHANGES, 1, len(STOCK_PRICE_CHANGES))    print(ans3)    print("----------------------------------------------------------------------------------")    print("MATRIX MULTIPLICATION OF THESE TWO SQUARE MATRICES:")    A = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])    B = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])    print(A)    print(B)    print("NORMAL SQUARE MATRIX MULTIPLICATION:")    ans4 = square_matrix_multiply(A, B)    print(ans4)    print("MATRIX MULTIPLICATION OF THESE TWO SQUARE MATRICES:")    A = np.array([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 1], [4, 5, 1, 2]])    B = np.array([[2, 3, 4, 5], [1, 2, 3, 4], [3, 4, 5, 1], [5, 1, 2, 3]])    print(A)    print(B)    print("MATRIX MULTIPLICATION USING STRASSEN'S METHOD:")    ans5 = square_matrix_multiply_strassens(A, B)    print(ans5)    passif __name__ == '__main__':    test()